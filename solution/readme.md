# Рекламная платформа PROD Backend 2025

### Инструкция по запуску приложения

Для запуска проекта используется `docker-compose.yml`, который содержит все необходимые сервисы для работы приложения. 
- **Docker**: Приложение упаковано в контейнеры Docker, что обеспечивает воспроизводимость среды и изоляцию зависимостей.
- **Port Mapping**: Приложение доступно на порту `8080`. Убедитесь, что порт свободен перед запуском.

```bash
docker-compose up -d
```

После запуска контейнеров, приложение будет доступно по адресу `http://localhost:8080`, grafana по адресу `http://localhost:3000`, minio по адресу `http://localhost:9000`.

#### Логины и пароли для сервисов:

- **Grafana**:
  - Адрес: `http://localhost:3000`
  - Логин: `admin`
  - Пароль: `admin`

- **MinIO**:
  - Адрес: `http://localhost:9000`
  - Порт: `9001:9001` (для панели управления)
  - Корневой пользователь: `minioadmin`
  - Корневой пароль: `minioadmin`

---

## Обоснованность решения

### Выбор технологий

#### PostgreSQL
**Преимущества:**
- Поддержка сложных запросов и транзакций (ACID).
- Надежное хранение реляционных данных.
- Возможность индексации для повышения производительности.
- Простая интеграция с SQLAlchemy ORM.

**Альтернативы:**
- **SQLite**: Меньше функционала, не подходит для многопользовательских систем.
- **MongoDB**: NoSQL, менее подходящий для структурированных данных вроде клиентов, рекламодателей и кампаний.

#### FastAPI
**Преимущества:**
- Высокая производительность благодаря асинхронности.
- Автоматическая генерация документации Swagger/OpenAPI.
- Валидация данных на основе Pydantic.
- Простота написания кода и его чтения.
- Хорошая экосистема плагинов и расширений.

**Альтернативы:**
- **Flask**: Более гибкий, но требует больше усилий для реализации тех же функций.
- **Django**: Слишком "тяжелый" для данного проекта, избыточный функционал.

#### Grafana
**Преимущества:**
- Визуализация данных в реальном времени.
- Легкость создания дашбордов.
- Интеграция с различными источниками данных (PostgreSQL).

**Альтернативы:**
- **Apache Superset**: Требует больше времени на настройку.
- **Custom Solution**: Сложнее в разработке и поддержке.

#### S3 + MinIO
**Преимущества:**
- Совместимость с S3 API позволяет легко заменить MinIO на облачное хранилище при необходимости.
- Распределенное хранение файлов.
- Защита данных через встроенные механизмы шифрования.

**Альтернативы:**
- **Google Cloud Storage**: Требует доступа к облаку, что может быть ограничено.
- **AWS S3**: Аналогично Google Cloud Storage.

#### LLM (Яндекс Cloud)
**Преимущества:**
- Генерация и модерация текстов на базе современных языковых моделей.
- Простая интеграция через SDK Яндекс Cloud.

**Альтернативы:**
- **OpenAI GPT**: Требует дополнительных затрат на использование.
- **Custom Models**: Сложнее в разработке и обучении.

---

## Демонстрация работы приложения

### Основные сценарии использования

1. **Регистрация клиентов и рекламодателей**
   - Клиенты регистрируются через метод `/clients/bulk`.
   - Рекламодатели регистрируются через метод `/advertisers/bulk`.

   **Пример:**
   ```bash
   curl -X POST http://localhost:8080/clients/bulk -H "Content-Type: application/json" -d '[
       {
           "client_id": "123e4567-e89b-12d3-a456-426614174000",
           "login": "user1",
           "age": 25,
           "location": "Moscow",
           "gender": "MALE"
       }
   ]'
   ```

2. **Создание рекламных кампаний**
   - Рекламодатели создают кампании через метод `/advertisers/{advertiser_id}/campaigns`.

   **Пример:**
   ```bash
   curl -X POST http://localhost:8080/advertisers/123e4567-e89b-12d3-a456-426614174001/campaigns -H "Content-Type: application/json" -d '{
       "impressions_limit": 100,
       "clicks_limit": 50,
       "cost_per_impression": 0.1,
       "cost_per_click": 0.5,
       "ad_title": "Test Campaign",
       "ad_text": "Sample text",
       "start_date": 1,
       "end_date": 7,
       "targeting": {
           "gender": "ALL",
           "age_from": 18,
           "age_to": 35,
           "location": "Moscow"
       }
   }'
   ```

3. **Показ рекламы**
   - Метод `/ads` возвращает наиболее релевантное объявление на основе ML-скоров, параметров кампании и текущего дня.

   **Пример:**
   ```bash
   curl -X GET http://localhost:8080/ads?client_id=123e4567-e89b-12d3-a456-426614174000
   ```

4. **Статистика**
   - Получение статистики через методы `/stats/campaigns/{campaign_id}` и `/stats/advertisers/{advertiser_id}/campaigns`.

   **Пример:**
   ```bash
   curl -X GET http://localhost:8080/stats/campaigns/123e4567-e89b-12d3-a456-426614174002
   ```

5. **Интеграция с LLM**
   - Генерация текстов для объявлений доступна через метод `/ads/generate-ad`.

   **Пример:**
   ```bash
   curl -X GET http://localhost:8080/ads/generate-ad?description="Описание продукта"
   ```

6. **Настройка времени**
   - Метод `/time/advance` позволяет установить текущий день для тестирования.

   **Пример:**
   ```bash
   curl -X POST http://localhost:8080/time/advance -H "Content-Type: application/json" -d '{"current_date": 2}'
   ```

7. **Загрузка файлов**
   - Метод `/files/upload` позволяет загружать файлы на сервер.

   **Пример:**
   ```bash
   curl -X POST http://localhost:8080/files/upload -F "files=@image.jpg" -F "advertiser_id=123e4567-e89b-12d3-a456-426614174001"
   ```

---

### Подробное описание алгоритма показа рекламы

Метод `/ads` работает следующим образом:

1. **Проверка таргетинга**:
   - Система проверяет соответствие клиента параметрам таргетинга кампании (пол, возраст, локация).

2. **Фильтрация по дате**:
   - Кампания должна быть активна в текущий день.

3. **Ограничения по лимитам**:
   - Проверяется, не превышены ли лимиты показов и переходов.

4. **Вычисление релевантности**:
   - Используется ML-скор для определения релевантности.

5. **Сортировка и выбор**:
   - Кампании ранжируются по комбинированному показателю:
     ```
     cost_per_impression + cost_per_click * normalized_ML_score
     ```
     где `normalized_ML_score = ml_score / max_ml_score`.

6. **Логирование показа**:
   - Если выбрано объявление, система фиксирует показ в таблице `UniqueImpressions`.

![get_ad_algorithm_schema.png](images/get_ad_algorithm_schema.png)

---

### Примеры работы системы

#### Создание кампании
```json
{
    "impressions_limit": 100,
    "clicks_limit": 50,
    "cost_per_impression": 0.1,
    "cost_per_click": 0.5,
    "ad_title": "Test Campaign",
    "ad_text": "Sample text",
    "start_date": 1,
    "end_date": 7,
    "targeting": {
        "gender": "ALL",
        "age_from": 18,
        "age_to": 35,
        "location": "Moscow"
    }
}
```

#### Показ рекламы
```json
{
    "ad_id": "123e4567-e89b-12d3-a456-426614174002",
    "ad_title": "Test Campaign",
    "ad_text": "Sample text",
    "advertiser_id": "123e4567-e89b-12d3-a456-426614174001"
}
```

#### Статистика кампании
```json
{
    "impressions_count": 50,
    "clicks_count": 20,
    "conversion": 40.0,
    "spent_impressions": 5.0,
    "spent_clicks": 10.0,
    "spent_total": 15.0
}
```

---

### Схема данных СУБД

#### Таблицы:

1. **Clients**:
   - `client_id`: Уникальный идентификатор клиента.
   - `login`: Логин пользователя.
   - `age`: Возраст.
   - `location`: Локация (город или район).
   - `gender`: Пол (`MALE`, `FEMALE`).

2. **Advertisers**:
   - `advertiser_id`: Уникальный идентификатор рекламодателя.
   - `name`: Название компании.

3. **Campaigns**:
   - `campaign_id`: Уникальный идентификатор кампании.
   - `advertiser_id`: Идентификатор рекламодателя.
   - `impressions_limit`: Лимит показов.
   - `clicks_limit`: Лимит переходов.
   - `cost_per_impression`: Стоимость одного показа.
   - `cost_per_click`: Стоимость одного перехода.
   - `ad_title`: Заголовок объявления.
   - `ad_text`: Текст объявления.
   - `start_date`: Дата начала кампании.
   - `end_date`: Дата окончания кампании.
   - `targeting`: Параметры таргетинга.
   - `is_deleted`: Поле для soft-delete

4. **Targetings**:
   - `campaign_id`: Идентификатор кампании.
   - `gender`: Целевой пол (`MALE`, `FEMALE`, `ALL`).
   - `age_from`: Минимальный возраст.
   - `age_to`: Максимальный возраст.
   - `location`: Локация.

5. **MLScores**:
   - `client_id`: Идентификатор клиента.
   - `advertiser_id`: Идентификатор рекламодателя.
   - `score`: ML-скор (релевантность).

6. **UniqueImpressions**:
   - `client_id`: Идентификатор клиента.
   - `campaign_id`: Идентификатор кампании.
   - `date`: Дата показа.
   - `cost`: Стоимость показа.

7. **UniqueClicks**:
   - `client_id`: Идентификатор клиента.
   - `campaign_id`: Идентификатор кампании.
   - `date`: Дата клика.
   - `cost`: Стоимость клика.

8. **CurrentDate**:
   - `current_date`: Текущий день для эмуляции времени.

#### Связи между таблицами:
- **Clients ↔ MLScores ↔ Advertisers**: MLScores связывают клиентов и рекламодателей.
- **Advertisers ↔ Campaigns**: Каждый рекламодатель может иметь несколько кампаний.
- **Campaigns ↔ Targetings**: Каждая кампания имеет параметры таргетинга.
- **Campaigns ↔ UniqueImpressions/UniqueClicks**: Для отслеживания показов и кликов.

### Схема базы данных

![database_schema.png](images/database_schema.png)


---

## Архитектурные решения

### Модульность
- **Клиенты**: Управление данными пользователей.
- **Рекламодатели**: Управление данными рекламодателей.
- **Кампании**: Создание, обновление и удаление рекламных кампаний.
- **Статистика**: Отображение метрик показов и переходов.
- **ML-скоры**: Хранение и обновление релевантности между клиентами и рекламодателями.
- **Время**: Настройка текущего дня для тестирования.

### Асинхронность
- Все CRUD-операции выполнены асинхронно для повышения производительности.
- Использование SQLAlchemy AsyncSession для взаимодействия с базой данных.

### Шаблоны проектирования
- **Repository Pattern**: Разделение логики доступа к данным от бизнес-логики.
- **Dependency Injection**: Использование зависимостей через FastAPI Dependency Injection.

---

## Особенности реализации

### Таргетинг
- Реализован через таблицу `Targetings`, которая связана с кампаниями.
- Поддерживает фильтрацию по полу, возрасту и локации.

### Лимиты показов и переходов
- Проверяются перед каждым показом или кликом.
- Лимиты нельзя изменять после старта кампании.

### ML-скоры
- Хранятся в таблице `MLScores`.
- Используются для вычисления релевантности между клиентами и рекламодателями.

### Визуализация статистики
- Используется Grafana для построения графиков и дашбордов.
- Доступны общие метрики (показы, клики, конверсия) и ежедневная статистика.

### Модерация текстов
- Реализована через REST API методы добавления запрещенных слов.
- По умолчанию отключена (можно включить через переменную окружения `MODERATE_AD_TEXT=true`).

### Генерация текстов
- Используется Yandex Cloud LLM для создания заголовков и текстов объявлений.
- Можно вызвать через метод `/ads/generate-ad`.

---

## Чистота кода

### Структура проекта
- **Модули**: Разделены по областям ответственности (клиенты, рекламодатели, кампании, статистика).
- **CRUD-операции**: Реализованы через SQLAlchemy ORM.
- **Асинхронность**: Использована для повышения производительности.

### Соблюдение стандартов
- **PEP 8**: Стиль кода соответствует стандартам Python.
- **DRY**: Избегается дублирование логики.
- **KISS**: Простота решения.
- **SOLID**: Архитектурные принципы применены для модульности и расширяемости.

---

## Тестирование

Проект покрыт юнит- и e2e-тестами.

### Юнит-тесты
- Проверяют работу отдельных компонентов (CRUD операции, валидацию данных).

### E2E-тесты
- Эмулируют реальные сценарии использования (регистрация клиента, создание кампании, получение рекламы).

---

## Плюсы существующего решения

1. **Архитектурные преимущества**:
   - Модульность: Компоненты легко заменяются и расширяются.
   - Асинхронность: Повышает производительность при высокой нагрузке.

2. **Технологические преимущества**:
   - FastAPI обеспечивает высокую скорость разработки и производительность.
   - PostgreSQL подходит для хранения реляционных данных с поддержкой сложных запросов.

3. **Идейные преимущества**:
   - Интеграция AI делает платформу современной и конкурентоспособной.
   - Гибкая система таргетинга позволяет точно настраивать показы.

---

## Планы по улучшению

1. **Scalability**:
   - Добавление Redis для кэширования часто используемых данных.
   - Горизонтальное масштабирование через Kubernetes.

2. **Security**:
   - Добавление авторизации и аутентификации (JWT).
   - Защита секретов через Vault.

3. **Monitoring**:
   - Интеграция с Prometheus для мониторинга производительности (удобно будет использовать при использовании реальных дат, сейчас прометеус не нуужен).

---